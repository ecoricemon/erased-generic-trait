//! # Trait object from trait with generic methods
//!
//! ## When to use
//!
//! - Want to make a trait obejct from a trait having some generic methods.
//! - Generic methods require 'static lifetime such as `foo<T: 'static>()`.
//!
//! ## Motivation
//!
//! In Rust, only object safe traits can become trait objects, generic methods make them not object safe.
//! To overcome this limitation, we can use `dyn Any` as parameters to take generic arguments
//! from non-generic methods, and call the generic methods in them.
//! We can inspect `TypeId`s from the 'dyn Ayn's, but we can't know concrete types from the 'TypeId's.
//! So macros are going to inject functions calling generic methods with the concrete types,
//! and invoke those functions according to the `TypeId`s.
//! It's inefficient but makes it possible.
//!
//! ## Usage
//!
//! You must use under macros all.
//! - erase_generic
//! - inject_fn_table
//! - generate_fn_table
//!
//! Please take a look at the example below.
//!
//! ## Example
//!
//! ```
//! pub trait Element: 'static {}
//!
//! // `ErasedGeneric` here is the arbitrary trait name to be generated.
//! #[erase_generic(ErasedGeneric)]
//! pub trait Generic {
//!     fn generic_writes<E: Element>(&mut self, param: &mut E);
//!     fn generic_reads<E: Element>(&mut self, param: &mut E);
//!     fn generic_multiple_arguments<E: Element>(
//!         &mut self,
//!         param1: &mut E,
//!         param2: &E,
//!         param3: i32,
//!     ) -> i32;
//!     fn foo(&self) -> &'static str;
//! }
//!
//! use core::mem::{swap, zeroed};
//! use erased_generic_trait::*;
//! use std::any::{Any, TypeId};
//!
//! // `ErasedGeneric` here is the trait name you used.
//! // Other signatures must be exactly same with methods in the trait.
//! #[inject_fn_table(
//!     ErasedGeneric;
//!     fn generic_writes<E: Element>(&mut self, param: &mut E);
//!     fn generic_reads<E: Element>(&mut self, param: &mut E);
//!     fn generic_multiple_arguments<E: Element>(
//!         &mut self,
//!         param1: &mut E,
//!         param2: &E,
//!         param3: i32
//!     ) -> i32;
//!     fn foo(&self) -> &'static str;
//! )]
//! struct Handler {
//!     v: Vec<Box<dyn Any>>, // Test Vec
//! }
//!
//! // Implements what you want.
//! impl Generic for Handler {
//!     fn generic_writes<E: Element>(&mut self, param: &mut E) {
//!         // Simple and unsafe writing test.
//!         let mut dummy: E = unsafe { zeroed() };
//!         swap(&mut dummy, param);
//!         let input = dummy;
//!         self.v.push(Box::new(input));
//!     }
//!
//!     fn generic_reads<E: Element>(&mut self, param: &mut E) {
//!         // Following reading test.
//!         let mut elem = self.v.pop().expect("There's no elements stacked.");
//!         if let Some(casted) = elem.downcast_mut::<E>() {
//!             swap(casted, param);
//!         }
//!     }
//!
//!     fn generic_multiple_arguments<E: Element>(
//!         &mut self,
//!         _param1: &mut E,
//!         _param2: &E,
//!         param3: i32,
//!     ) -> i32 {
//!         param3 + 1
//!     }
//!
//!     fn foo(&self) -> &'static str {
//!         "Handler::foo()"
//!     }
//! }
//!
//! #[derive(Debug, PartialEq)]
//! struct A {
//!     _a1: u8,
//!     _a2: u8,
//! }
//!
//! #[derive(Debug, PartialEq)]
//! struct B {
//!     _b1: u16,
//! }
//!
//! impl Element for A {}
//! impl Element for B {}
//!
//! // Constructs a trait object.
//! // `fn_table` here is generated by above macros.
//! // `Handler` is the implementation of generic trait.
//! // `A` and `B` are types that will be used with the generic methods.
//! let handler = Handler {
//!     fn_table: generate_fn_table!(Handler, A, B),
//!     v: Vec::new(),
//! };
//!
//! // You can see a trait object from an implementation of the generic trait.
//! let mut trait_object: Box<dyn ErasedGeneric> = Box::new(handler);
//!
//! // Writes something.
//! trait_object.generic_writes(&mut A { _a1: 1, _a2: 2 });
//! trait_object.generic_writes(&mut B { _b1: 3 });
//!
//! // Reads back.
//! let mut a_read = A { _a1: 0, _a2: 0 };
//! let mut b_read = B { _b1: 0 };
//! trait_object.generic_reads(&mut b_read);
//! trait_object.generic_reads(&mut a_read);
//! assert_eq!(A { _a1: 1, _a2: 2 }, a_read);
//! assert_eq!(B { _b1: 3 }, b_read);
//!
//! // Calls methods with multiple arguments.
//! let ret = trait_object.generic_multiple_arguments(
//!     &mut A { _a1: 1, _a2: 2 },
//!     &A { _a1: 3, _a2: 4 },
//!     1,
//! );
//! assert_eq!(2, ret);
//!
//! // Calls non-generic method.
//! trait_object.foo();
//! ```
//!
//! ## Pattern explanation
//!
//! > <https://github.com/ecoricemon/rust-patterns/blob/main/generic-trait-object/src/main.rs>

use proc_macro::TokenStream;

mod common;
mod erase_generic;
mod generate_fn_table;
mod inject_fn_table;

/// Generates a new trait that doesn't have generic methods in it.
/// All generic methods are changed into non-generic methods,
/// which have names like `erased_foo()`.
/// Currently, supports only one generic parameter for all methods.
///
/// # Examples
///
/// ```
/// # use erased_generic_trait::*;
/// trait Element: 'static + std::fmt::Debug {}
///
/// // Put in a new trait name.
/// #[erase_generic(ErasedGeneric)]
/// trait Generic {
///     // Must receive &mut self for now.
///     // Must receive generic arguments as & or &mut for now.
///     fn generic<E: Element>(&mut self, param: &mut E);
/// }
/// ```
#[proc_macro_attribute]
pub fn erase_generic(attr: TokenStream, item: TokenStream) -> TokenStream {
    erase_generic::erase_generic(attr, item)
}

/// Injects a function table into the struct in order to dispatch generic methods dinamically.
/// Please put in the new trait name you used at the generic trait,
/// and method signatures of the generic trait.
///
/// # Examples
///
/// ```
/// # use erased_generic_trait::*;
/// # trait Element: 'static {}
/// # #[erase_generic(ErasedGeneric)]
/// # trait Generic {
/// #     fn generic<E: Element>(&mut self, param: &mut E);
/// # }
/// # impl Generic for Handler {
/// #   fn generic<E: Element>(&mut self, _param: &mut E) {}
/// # }
/// #[inject_fn_table(
///     ErasedGeneric;
///     fn generic<E: Element>(&mut self, param: &mut E);
/// )]
/// struct Handler {}
///
/// ```
#[proc_macro_attribute]
pub fn inject_fn_table(attr: TokenStream, item: TokenStream) -> TokenStream {
    inject_fn_table::inject_fn_table(attr, item)
}

/// Generates a new function table for you.
/// Please use this macro at the constuctors of your generic implementations.
///
/// # Examples
///
/// ```
/// # use erased_generic_trait::*;
/// # trait Element: 'static {}
/// # #[erase_generic(ErasedGeneric)]
/// # trait Generic {
/// #     fn generic<E: Element>(&mut self, param: &mut E);
/// # }
/// # impl Generic for Handler {
/// #   fn generic<E: Element>(&mut self, _param: &mut E) {}
/// # }
/// # #[inject_fn_table(
/// #     ErasedGeneric;
/// #     fn generic<E: Element>(&mut self, param: &mut E);
/// # )]
/// # struct Handler {}
/// # impl Element for A {}
/// # impl Element for B {}
/// // Assumes that these structs will be passed into generic methods.
/// struct A;
/// struct B;
///
/// // Assumes that `Handler` here is a implementation of your generic trait.
/// let handler = Handler {
///     // fn_table is injected by `inject_fn_table` macro.
///     fn_table: generate_fn_table!(Handler, A, B),
///     // Else you need to initialize.
/// };
/// ```
#[proc_macro]
pub fn generate_fn_table(input: TokenStream) -> TokenStream {
    generate_fn_table::generate_fn_table(input)
}
